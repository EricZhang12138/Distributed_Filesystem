/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "fileops.h"
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<libgen.h>
#include<sys/stat.h>


void
fileopenprog_1(char *host, char *filePath)
{
	CLIENT *clnt;
	file_chunk  *result_1;
	file_chunk_info  fileopen_1_arg;

#ifndef	DEBUG
	clnt = clnt_create (host, FILEOPENPROG, FILEOPENVERS, "tcp");
	if (clnt == NULL) {
		clnt_pcreateerror (host);
		exit (1);
	}
#endif	/* DEBUG */

	FILE *fp;
	char dest[256];
	char fcpy[256];	
	strncpy(fcpy, filePath, sizeof(fcpy)-1);
	fcpy[sizeof(fcpy)-1] = '\0';
	char *fileName = basename(fcpy);

	snprintf(dest, sizeof(dest), "./tmp/%s", fileName);
//	printf("dest = %s\n", dest);
	if((fp = fopen(dest, "wb+"))==NULL){
		clnt_perror(clnt, "Cant open file\n");
		clnt_destroy(clnt);
		exit(1);
	}
	fileopen_1_arg.filePath = filePath;
	fileopen_1_arg.offset = 0;

	do{
		result_1 = fileopen_1(&fileopen_1_arg, clnt);
		if (result_1 == (file_chunk *) NULL) {
			clnt_perror (clnt, "call failed");
		}
	//	printf("received %s\n", result_1->data);
		fwrite(result_1->data, 1, result_1->size, fp);
		fileopen_1_arg.offset += result_1->size;
	}while(!result_1->last);
#ifndef	DEBUG
	fclose(fp);
	clnt_destroy (clnt);
#endif	 /* DEBUG */
}


void
filecloseprog_1(char *host, char *filePath)
{
	CLIENT *clnt;
	file_chunk  *result_1;
	file_flush_data  fileclose_1_arg;

#ifndef	DEBUG
	clnt = clnt_create (host, FILECLOSEPROG, FILECLOSEVERS, "udp");
	if (clnt == NULL) {
		clnt_pcreateerror (host);
		exit (1);
	}
#endif	/* DEBUG */

	FILE *fp;
	char dest[256];
	char fcpy[256];	
	strncpy(fcpy, filePath, sizeof(fcpy)-1);
	fcpy[sizeof(fcpy)-1] = '\0';
	int offset = 0;
	char *fileName = basename(fcpy);
	size_t bytesread;
	
	fileclose_1_arg.filePath = filePath;
	snprintf(dest, sizeof(dest), "./tmp/%s", fileName);
//	printf("dest = %s\n", dest);
	if((fp = fopen(dest, "rb+"))==NULL){
		perror("Cant open file on client\n");
		clnt_destroy(clnt);
		exit(1);
	}
	do{	
		bytesread = fread(fileclose_1_arg.data, 1, FILE_BLOCK, fp);
		fileclose_1_arg.size = bytesread;
		fileclose_1_arg.last = feof(fp);
		fileclose_1_arg.offset = offset;
		offset += fileclose_1_arg.size;
		result_1 = fileclose_1(&fileclose_1_arg, clnt);
		if (result_1 == (file_chunk *) NULL) {
			clnt_perror (clnt, "call failed");
		}
	}while(!result_1->last && bytesread > 0);
#ifndef	DEBUG
	fclose(fp);
	clnt_destroy (clnt);
#endif	 /* DEBUG */
}


void
filereadprog_1(char *host)
{
	CLIENT *clnt;
	file_chunk  *result_1;
	file_chunk_info  fileread_1_arg;

#ifndef	DEBUG
	clnt = clnt_create (host, FILEREADPROG, FILEREADVERS, "udp");
	if (clnt == NULL) {
		clnt_pcreateerror (host);
		exit (1);
	}
#endif	/* DEBUG */

	result_1 = fileread_1(&fileread_1_arg, clnt);
	if (result_1 == (file_chunk *) NULL) {
		clnt_perror (clnt, "call failed");
	}
#ifndef	DEBUG
	clnt_destroy (clnt);
#endif	 /* DEBUG */
}


void
filecreateprog_1(char *host)
{
	CLIENT *clnt;
	file_chunk  *result_1;
	file_chunk_info  filecreate_1_arg;

#ifndef	DEBUG
	clnt = clnt_create (host, FILECREATEPROG, FILECREATEVERS, "udp");
	if (clnt == NULL) {
		clnt_pcreateerror (host);
		exit (1);
	}
#endif	/* DEBUG */

	result_1 = filecreate_1(&filecreate_1_arg, clnt);
	if (result_1 == (file_chunk *) NULL) {
		clnt_perror (clnt, "call failed");
	}
#ifndef	DEBUG
	clnt_destroy (clnt);
#endif	 /* DEBUG */
}


int
main (int argc, char *argv[])
{
	char *host, *path;

	if (argc < 3) {
		printf ("usage: %s <server_host> <file_path>\n", argv[0]);
		exit (1);
	}
	host = argv[1];
	path = argv[2];
	fileopenprog_1 (host, path);
//	filecloseprog_1 (host, path);
	//filereadprog_1 (host);
	//filecreateprog_1 (host);
exit (0);
}
